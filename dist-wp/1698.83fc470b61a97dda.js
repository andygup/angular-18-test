"use strict";(self.webpackChunkangular_18_test=self.webpackChunkangular_18_test||[]).push([[1698],{71698:(W,m,o)=>{o.r(m),o.d(m,{assetMapFromAssetMapsJSON:()=>P,extractMesh:()=>O,meshFeatureSetFromJSON:()=>d});var g=o(81098),A=o(35150),M=o(60797),h=o(28067),p=o(62767),y=o(1749),T=o(32034),I=o(36812),D=o(33019),L=o(6829),R=o(93327);const S=()=>A.A.getLogger("esri.rest.support.meshFeatureSet");function d(t,e,s){const n=s.features;s.features=[],delete s.geometryType;const r=R.A.fromJSON(s);if(r.geometryType="mesh",!s.assetMaps)return r;const a=P(e,s.assetMaps),l=t.sourceSpatialReference??T.A.WGS84,f=s.globalIdFieldName,{outFields:u}=t,c=null!=u&&u.length>0?function C(t){return({attributes:e})=>{if(!e)return{};if(!t)return e;for(const s in e)t.has(s)||delete e[s];return e}}(u.includes("*")?null:new Set(u)):()=>({});for(const i of n){const _=O(i,f,l,e,a);r.features.push(new g.A({geometry:_,attributes:c(i)}))}return r}function O(t,e,s,n,r){const l=r.get(t.attributes[e]);if(null==l||!t.geometry)return null;const f=function v({attributes:t},e,{transformFieldRoles:s}){return new y.A({x:t[s.originX],y:t[s.originY],z:t[s.originZ],spatialReference:e})}(t,s,n),u=h.A.fromJSON(t.geometry);u.spatialReference=s;const c=function F(t,{transformFieldRoles:e}){return new I.A({translation:[t[e.translationX],-t[e.translationZ],t[e.translationY]],rotationAxis:[t[e.rotationX],-t[e.rotationZ],t[e.rotationY]],rotationAngle:t[e.rotationDeg],scale:[t[e.scaleX],t[e.scaleZ],t[e.scaleY]]})}(t.attributes,n),i=s.isGeographic?"local":"georeferenced",_=function U(t){const e=Array.from(t.files.values()),s=new Array;for(const n of e){if(n.status!==E.COMPLETED)return null;const r=new Array;for(const a of n.parts){if(!a)return null;r.push(new D.Bq(a.url,a.hash))}s.push(new D.Qp(n.name,n.mimeType,r))}return s}(l);return _?p.A.createWithExternalSource(f,_,{extent:u,transform:c,vertexSpace:i}):p.A.createIncomplete(f,{extent:u,transform:c,vertexSpace:i})}var E,t;function P(t,e){const s=new Map;for(const n of e){const r=n.parentGlobalId;if(null==r)continue;const a=n.assetName,l=n.assetType,f=n.assetHash,u=n.assetURL,c=n.conversionStatus,i=n.seqNo,_=(0,L.Fm)(l,t.supportedFormats);if(!_){S().error("mesh-feature-set:unknown-format",`Service returned an asset of type ${l}, but it does not list it as a supported type`);continue}const B=(0,M.tE)(s,r,()=>({files:new Map}));(0,M.tE)(B.files,a,()=>({name:a,type:l,mimeType:_,status:N(c),parts:[]})).parts[i]={hash:f,url:u}}return s}function N(t){switch(t){case"COMPLETED":case"SUBMITTED":return E.COMPLETED;case"INPROGRESS":return E.PENDING;default:return E.FAILED}}(t=E||(E={}))[t.FAILED=0]="FAILED",t[t.PENDING=1]="PENDING",t[t.COMPLETED=2]="COMPLETED"}}]);
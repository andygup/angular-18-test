"use strict";(self.webpackChunkangular_18_test=self.webpackChunkangular_18_test||[]).push([[192],{12225:(H,Y,C)=>{function y(){return new Float32Array(3)}function A(a){const l=new Float32Array(3);return l[0]=a[0],l[1]=a[1],l[2]=a[2],l}function L(a,l,b){const O=new Float32Array(3);return O[0]=a,O[1]=l,O[2]=b,O}function I(){return y()}function T(){return L(1,1,1)}function R(){return L(1,0,0)}function x(){return L(0,1,0)}function k(){return L(0,0,1)}C.d(Y,{fA:()=>L,o8:()=>A,vt:()=>y});const F=I(),V=T(),X=R(),P=x(),N=k();Object.freeze(Object.defineProperty({__proto__:null,ONES:V,UNIT_X:X,UNIT_Y:P,UNIT_Z:N,ZEROS:F,clone:A,create:y,createView:function z(a,l){return new Float32Array(a,l,3)},fromValues:L,ones:T,unitX:R,unitY:x,unitZ:k,zeros:I},Symbol.toStringTag,{value:"Module"}))},90192:(H,Y,C)=>{C.r(Y),C.d(Y,{default:()=>t});var y=C(89952),A=C(79139),L=C(19890),z=C(14214),I=C(28714),T=C(12225),R=C(32034),x=C(23234),F=(C(3248),C(49873)),V=C(87862),X=C(87701),P=C(70787),N=C(46835);function l(s,e,r){return s?.attributeInfo.useElevation?e?function b(s,e){const r=new Float64Array(e);for(let o=0;o<e;o++)r[o]=s[3*o+2];return r}(e,r):null:s?.attributeInfo.storageInfo?(0,P.m0)(s.attributeInfo.storageInfo,s.buffer,r):null}function D(s){switch(s){default:case null:case"none":return e=>e;case"low-four-bit":return e=>15&e;case"high-four-bit":return e=>(240&e)>>4;case"absolute-value":return e=>Math.abs(e);case"modulo-ten":return e=>e%10}}function c(s){let e=0;for(const r of s||[])e|=1<<r;return e}var U=C(19641);class B{transform(e){const r=this._transform(e),o=[r.points.buffer,r.rgb.buffer];null!=r.pointIdFilterMap&&o.push(r.pointIdFilterMap.buffer);for(const f of r.attributes)"buffer"in f.values&&(0,A.mw)(f.values.buffer)&&f.values.buffer!==r.rgb.buffer&&o.push(f.values.buffer);return Promise.resolve({result:r,transferList:o})}_transform(e){const r=function a(s,e){if(null==s.encoding||""===s.encoding){const r=(0,P.wH)(e,s);if(null==r.vertexAttributes.position)return;const o=(0,P.MA)(e,r.vertexAttributes.position),f=r.header.fields,v=[f.offsetX,f.offsetY,f.offsetZ],i=[f.scaleX,f.scaleY,f.scaleZ],d=o.length/3,u=new Float64Array(3*d);for(let p=0;p<d;p++)u[3*p]=o[3*p]*i[0]+v[0],u[3*p+1]=o[3*p+1]*i[1]+v[1],u[3*p+2]=o[3*p+2]*i[2]+v[2];return u}if("lepcc-xyz"===s.encoding)return(0,N.Me)(e).result}(e.schema,e.geometryBuffer);let o=r.length/3,f=null;const v=new Array,i=l(e.primaryAttributeData,r,o);null!=e.primaryAttributeData&&i&&v.push({attributeInfo:e.primaryAttributeData.attributeInfo,values:i});const d=l(e.modulationAttributeData,r,o);null!=e.modulationAttributeData&&d&&v.push({attributeInfo:e.modulationAttributeData.attributeInfo,values:d});let u=function Z(s,e,r,o){const{rendererJSON:f,isRGBRenderer:v}=s;let i=null,d=null;if(e&&v)i=e;else if(e&&"pointCloudUniqueValueRenderer"===f?.type){d=X.A.fromJSON(f);const u=d.colorUniqueValueInfos;i=new Uint8Array(3*o);const p=D(d.fieldTransformType);for(let g=0;g<o;g++){const h=(p?p(e[g]):e[g])+"";for(let m=0;m<u.length;m++)if(u[m].values.includes(h)){i[3*g]=u[m].color.r,i[3*g+1]=u[m].color.g,i[3*g+2]=u[m].color.b;break}}}else if(e&&"pointCloudStretchRenderer"===f?.type){d=V.A.fromJSON(f);const u=d.stops;i=new Uint8Array(3*o);const p=D(d.fieldTransformType);for(let g=0;g<o;g++){const h=p?p(e[g]):e[g],m=u.length-1;if(h<u[0].value)i[3*g]=u[0].color.r,i[3*g+1]=u[0].color.g,i[3*g+2]=u[0].color.b;else if(h>=u[m].value)i[3*g]=u[m].color.r,i[3*g+1]=u[m].color.g,i[3*g+2]=u[m].color.b;else for(let M=1;M<u.length;M++)if(h<u[M].value){const S=(h-u[M-1].value)/(u[M].value-u[M-1].value);i[3*g]=u[M].color.r*S+u[M-1].color.r*(1-S),i[3*g+1]=u[M].color.g*S+u[M-1].color.g*(1-S),i[3*g+2]=u[M].color.b*S+u[M-1].color.b*(1-S);break}}}else if(e&&"pointCloudClassBreaksRenderer"===f?.type){d=F.A.fromJSON(f);const u=d.colorClassBreakInfos;i=new Uint8Array(3*o);const p=D(d.fieldTransformType);for(let g=0;g<o;g++){const h=p?p(e[g]):e[g];for(let m=0;m<u.length;m++)if(h>=u[m].minValue&&h<=u[m].maxValue){i[3*g]=u[m].color.r,i[3*g+1]=u[m].color.g,i[3*g+2]=u[m].color.b;break}}}else i=new Uint8Array(3*o).fill(255);if(r&&d?.colorModulation){const u=d.colorModulation.minValue,p=d.colorModulation.maxValue,g=.3;for(let h=0;h<o;h++){const m=r[h],M=m>=p?1:m<=u?g:g+(1-g)*(m-u)/(p-u);i[3*h]=M*i[3*h],i[3*h+1]=M*i[3*h+1],i[3*h+2]=M*i[3*h+2]}}return i}(e.rendererInfo,i,d,o);if(e.filterInfo&&e.filterInfo.length>0&&null!=e.filterAttributesData){const g=e.filterAttributesData.filter(y.Ru).map(h=>{const m=l(h,r,o),M={attributeInfo:h.attributeInfo,values:m};return v.push(M),M});f=new Uint32Array(o),o=function O(s,e,r,o,f){const v=s.length/3;let i=0;for(let d=0;d<v;d++){let u=!0;for(let p=0;p<o.length&&u;p++){const{filterJSON:g}=o[p],h=f[p].values[d];switch(g.type){case"pointCloudValueFilter":{const m="exclude"===g.mode;g.values.includes(h)===m&&(u=!1);break}case"pointCloudBitfieldFilter":{const m=c(g.requiredSetBits),M=c(g.requiredClearBits);((h&m)!==m||h&M)&&(u=!1);break}case"pointCloudReturnFilter":{const m=15&h,M=h>>>4&15,S=M>1,K=1===m,W=m===M;let J=!1;for(const j of g.includedReturns)if("last"===j&&W||"firstOfMany"===j&&K&&S||"lastOfMany"===j&&W&&S||"single"===j&&!S){J=!0;break}J||(u=!1);break}}}u&&(r[i]=d,s[3*i]=s[3*d],s[3*i+1]=s[3*d+1],s[3*i+2]=s[3*d+2],e[3*i]=e[3*d],e[3*i+1]=e[3*d+1],e[3*i+2]=e[3*d+2],i++)}return i}(r,u,f,e.filterInfo,g)}for(const g of e.userAttributesData){const h=l(g,r,o);v.push({attributeInfo:g.attributeInfo,values:h})}3*o<u.length&&(u=new Uint8Array(u.buffer.slice(0,3*o))),function E(s,e,r){if(0!==r)for(let o=0;o<e;o++)s[3*o+2]+=r}(r,o,e.elevationOffset);const p=function w(s,e,r,o,f){if(!(0,x.projectBuffer)(s,o,0,s,f,0,e))throw new Error("Can't reproject");const v=(0,T.o8)(r.center),i=(0,T.vt)(),d=(0,T.vt)(),u=(0,T.o8)(r.halfSize);(0,L.Xr)(n,r.quaternion);const p=new Float32Array(3*e);for(let g=0;g<e;g++){let h=3*g;i[0]=s[h]-v[0],i[1]=s[h+1]-v[1],i[2]=s[h+2]-v[2],(0,I.v)(d,i,n),u[0]=Math.max(u[0],Math.abs(d[0])),u[1]=Math.max(u[1],Math.abs(d[1])),u[2]=Math.max(u[2],Math.abs(d[2])),p[h++]=i[0],p[h++]=i[1],p[h]=i[2]}return r.halfSize=u,p}(r,o,U.ab.fromData(e.obbData),R.A.fromJSON(e.inSR),R.A.fromJSON(e.outSR));return{obbData:e.obbData,points:p,rgb:u,attributes:v,pointIdFilterMap:f}}}const n=(0,z.vt)();function t(){return new B}},70787:(H,Y,C)=>{C.d(Y,{MA:()=>V,m0:()=>c,wH:()=>a});var y=C(5922),A=C(77806),L=C(35150),z=C(46835),I=C(40972);const T=()=>L.A.getLogger("esri.views.3d.layers.i3s.I3SBinaryReader");function R(n,t,s){let e="",r=0;for(;r<s;){const o=n[t+r];if(o<128)e+=String.fromCharCode(o),r++;else if(o>=192&&o<224){if(r+1>=s)throw new y.A("utf8-decode-error","UTF-8 Decode failed. Two byte character was truncated.");e+=String.fromCharCode((31&o)<<6|63&n[t+r+1]),r+=2}else if(o>=224&&o<240){if(r+2>=s)throw new y.A("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");e+=String.fromCharCode((15&o)<<12|(63&n[t+r+1])<<6|63&n[t+r+2]),r+=3}else{if(!(o>=240&&o<248))throw new y.A("utf8-decode-error","UTF-8 Decode failed. Invalid multi byte sequence.");{if(r+3>=s)throw new y.A("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");const f=(7&o)<<18|(63&n[t+r+1])<<12|(63&n[t+r+2])<<6|63&n[t+r+3];e+=f>=65536?String.fromCharCode(55296+(f-65536>>10),56320+(1023&f)):String.fromCharCode(f),r+=4}}}return e}function x(n,t){const s={byteOffset:0,byteCount:0,fields:Object.create(null)};let e=0;for(let r=0;r<t.length;r++){const o=t[r],f=o.valueType||o.type;s.fields[o.property]=(0,B[f])(n,e),e+=U[f].BYTES_PER_ELEMENT}return s.byteCount=e,s}function F(n,t,s){const e=[];let r,o,f=0;for(o=0;o<n;o+=1){if(r=t[o],r>0){if(e.push(R(s,f,r-1)),0!==s[f+r-1])throw new y.A("string-array-error","Invalid string array: missing null termination.")}else e.push(null);f+=r}return e}function V(n,t){return new U[t.valueType](n,t.byteOffset,t.count*t.valuesPerElement)}function N(n,t,s){if(t!==n&&T().error(`Invalid ${s} buffer size\n expected: ${n}, actual: ${t})`),t<n)throw new y.A("buffer-too-small","Binary buffer is too small",{expectedSize:n,actualSize:t})}function a(n,t){const s=x(n,t&&t.header);let e=s.byteCount;const r={isDraco:!1,header:s,byteOffset:s.byteCount,byteCount:0,vertexAttributes:{}},o=s.fields,f=null!=o.vertexCount?o.vertexCount:o.count;for(const d of t.ordering){if(!t.vertexAttributes[d])continue;const u={...t.vertexAttributes[d],byteOffset:e,count:f};r.vertexAttributes[D[d]||"_"+d]=u,e+=E(u.valueType)*u.valuesPerElement*f}const v=o.faceCount;if(t.faces&&v){r.faces={};for(const d of t.ordering){if(!t.faces[d])continue;const u={...t.faces[d],byteOffset:e,count:v};r.faces[d]=u,e+=E(u.valueType)*u.valuesPerElement*v}}const i=o.featureCount;if(t.featureAttributes&&t.featureAttributeOrder&&i){r.featureAttributes={};for(const d of t.featureAttributeOrder){if(!t.featureAttributes[d])continue;const u={...t.featureAttributes[d],byteOffset:e,count:i};r.featureAttributes[d]=u,e+=("UInt64"===u.valueType?8:E(u.valueType))*u.valuesPerElement*i}}return N(e,n.byteLength,"geometry"),r.byteCount=e-r.byteOffset,r}const D={position:I.r.POSITION,normal:I.r.NORMAL,color:I.r.COLOR,uv0:I.r.UV0,region:I.r.UVREGION};function c(n,t,s){if("lepcc-rgb"===n.encoding)return(0,z.mb)(t);if("lepcc-intensity"===n.encoding)return(0,z.Ax)(t);if(null!=n.encoding&&""!==n.encoding)throw new y.A("unknown-attribute-storage-info-encoding","Unknown Attribute Storage Info Encoding");n["attributeByteCounts "]&&!n.attributeByteCounts&&(T().warn("Warning: Trailing space in 'attributeByteCounts '."),n.attributeByteCounts=n["attributeByteCounts "]),"ObjectIds"===n.ordering[0]&&n.hasOwnProperty("objectIds")&&(T().warn("Warning: Case error in objectIds"),n.ordering[0]="objectIds");const e=function P(n,t,s){const e=null!=t.header?x(n,t.header):{byteOffset:0,byteCount:0,fields:{count:s}},r={header:e,byteOffset:e.byteCount,byteCount:0,entries:Object.create(null)};let o=e.byteCount;for(let f=0;f<t.ordering.length;f++){const v=t.ordering[f],i=(0,A.o8)(t[v]);if(i.count=e.fields.count??0,"String"===i.valueType){if(i.byteOffset=o,i.byteCount=e.fields[v+"ByteCount"],"UTF-8"!==i.encoding)throw new y.A("unsupported-encoding","Unsupported String encoding.",{encoding:i.encoding});if(i.timeEncoding&&"ECMA_ISO8601"!==i.timeEncoding)throw new y.A("unsupported-time-encoding","Unsupported time encoding.",{timeEncoding:i.timeEncoding})}else{if(!w(i.valueType))throw new y.A("unsupported-value-type","Unsupported binary valueType",{valueType:i.valueType});{const d=E(i.valueType);o+=o%d!=0?d-o%d:0,i.byteOffset=o,i.byteCount=d*i.valuesPerElement*i.count}}o+=i.byteCount??0,r.entries[v]=i}return r.byteCount=o-r.byteOffset,r}(t,n,s);N(e.byteOffset+e.byteCount,t.byteLength,"attribute");const r=e.entries.attributeValues||e.entries.objectIds;if(r){if("String"===r.valueType){const o=e.entries.attributeByteCounts,f=V(t,o),v=function X(n,t){return new Uint8Array(n,t.byteOffset,t.byteCount)}(t,r);return r.timeEncoding?function k(n,t,s){return F(n,t,s).map(e=>{const r=e?Date.parse(e):null;return r&&!Number.isNaN(r)?r:null})}(o.count,f,v):F(o.count,f,v)}return V(t,r)}throw new y.A("bad-attribute-storage-info","Bad attributeStorageInfo specification.")}const U={Float32:Float32Array,Float64:Float64Array,UInt8:Uint8Array,Int8:Int8Array,UInt16:Uint16Array,Int16:Int16Array,UInt32:Uint32Array,Int32:Int32Array},B={Float32:(n,t)=>new DataView(n,0).getFloat32(t,!0),Float64:(n,t)=>new DataView(n,0).getFloat64(t,!0),UInt8:(n,t)=>new DataView(n,0).getUint8(t),Int8:(n,t)=>new DataView(n,0).getInt8(t),UInt16:(n,t)=>new DataView(n,0).getUint16(t,!0),Int16:(n,t)=>new DataView(n,0).getInt16(t,!0),UInt32:(n,t)=>new DataView(n,0).getUint32(t,!0),Int32:(n,t)=>new DataView(n,0).getInt32(t,!0)};function w(n){return U.hasOwnProperty(n)}function E(n){return w(n)?U[n].BYTES_PER_ELEMENT:0}},46835:(H,Y,C)=>{C.d(Y,{Ax:()=>Z,Me:()=>R,mb:()=>X});var y=C(5922);const A=!0,L={identifierOffset:0,identifierLength:10,versionOffset:10,checksumOffset:12,byteCount:16};function z(a,l,b){return{identifier:String.fromCharCode.apply(null,new Uint8Array(a,b+L.identifierOffset,L.identifierLength)),version:l.getUint16(b+L.versionOffset,A),checksum:l.getUint32(b+L.checksumOffset,A)}}const I={sizeLo:0,sizeHi:4,minX:8,minY:16,minZ:24,maxX:32,maxY:40,maxZ:48,errorX:56,errorY:64,errorZ:72,count:80,reserved:84,byteCount:88};function R(a){const l=new DataView(a,0);let b=0;const{identifier:O,version:D}=z(a,l,b);if(b+=L.byteCount,"LEPCC     "!==O)throw new y.A("lepcc-decode-error","Bad identifier");if(D>1)throw new y.A("lepcc-decode-error","Unknown version");const c=function T(a,l){return{sizeLo:a.getUint32(l+I.sizeLo,A),sizeHi:a.getUint32(l+I.sizeHi,A),minX:a.getFloat64(l+I.minX,A),minY:a.getFloat64(l+I.minY,A),minZ:a.getFloat64(l+I.minZ,A),maxX:a.getFloat64(l+I.maxX,A),maxY:a.getFloat64(l+I.maxY,A),maxZ:a.getFloat64(l+I.maxZ,A),errorX:a.getFloat64(l+I.errorX,A),errorY:a.getFloat64(l+I.errorY,A),errorZ:a.getFloat64(l+I.errorZ,A),count:a.getUint32(l+I.count,A),reserved:a.getUint32(l+I.reserved,A)}}(l,b);if(b+=I.byteCount,c.sizeHi*2**32+c.sizeLo!==a.byteLength)throw new y.A("lepcc-decode-error","Bad size");const U=new Float64Array(3*c.count),B=[],w=[],E=[],n=[];if(b=x(a,b,B),b=x(a,b,w),b=x(a,b,E),b=x(a,b,n),b!==a.byteLength)throw new y.A("lepcc-decode-error","Bad length");let t=0,s=0;for(let e=0;e<B.length;e++){s+=B[e];let r=0;for(let o=0;o<w[e];o++){r+=E[t];const f=n[t];U[3*t]=Math.min(c.maxX,c.minX+2*c.errorX*r),U[3*t+1]=Math.min(c.maxY,c.minY+2*c.errorY*s),U[3*t+2]=Math.min(c.maxZ,c.minZ+2*c.errorZ*f),t++}}return{errorX:c.errorX,errorY:c.errorY,errorZ:c.errorZ,result:U}}function x(a,l,b){const O=[];l=k(a,l,O);const D=[];for(let c=0;c<O.length;c++){D.length=0,l=k(a,l,D);for(let U=0;U<D.length;U++)b.push(D[U]+O[c])}return l}function k(a,l,b){const O=new DataView(a,l),D=O.getUint8(0),c=31&D,U=!!(32&D),B=(192&D)>>6;let w=0;if(0===B)w=O.getUint32(1,A),l+=5;else if(1===B)w=O.getUint16(1,A),l+=3;else{if(2!==B)throw new y.A("lepcc-decode-error","Bad count type");w=O.getUint8(1),l+=2}if(U)throw new y.A("lepcc-decode-error","LUT not implemented");const E=Math.ceil(w*c/8),n=new Uint8Array(a,l,E);let t=0,s=0,e=0;const r=-1>>>32-c;for(let o=0;o<w;o++){for(;s<c;)t|=n[e]<<s,s+=8,e+=1;b[o]=t&r,t>>>=c,s-=c,s+c>32&&(t|=n[e-1]>>8-s)}return l+e}const F={sizeLo:0,sizeHi:4,count:8,colorMapCount:12,lookupMethod:14,compressionMethod:15,byteCount:16};function X(a){const l=new DataView(a,0);let b=0;const{identifier:O,version:D}=z(a,l,b);if(b+=L.byteCount,"ClusterRGB"!==O)throw new y.A("lepcc-decode-error","Bad identifier");if(D>1)throw new y.A("lepcc-decode-error","Unknown version");const c=function V(a,l){return{sizeLo:a.getUint32(l+F.sizeLo,A),sizeHi:a.getUint32(l+F.sizeHi,A),count:a.getUint32(l+F.count,A),colorMapCount:a.getUint16(l+F.colorMapCount,A),lookupMethod:a.getUint8(l+F.lookupMethod),compressionMethod:a.getUint8(l+F.compressionMethod)}}(l,b);if(b+=F.byteCount,c.sizeHi*2**32+c.sizeLo!==a.byteLength)throw new y.A("lepcc-decode-error","Bad size");if((2===c.lookupMethod||1===c.lookupMethod)&&0===c.compressionMethod){if(3*c.colorMapCount+c.count+b!==a.byteLength||c.colorMapCount>256)throw new y.A("lepcc-decode-error","Bad count");const U=new Uint8Array(a,b,3*c.colorMapCount),B=new Uint8Array(a,b+3*c.colorMapCount,c.count),w=new Uint8Array(3*c.count);for(let E=0;E<c.count;E++){const n=B[E];w[3*E]=U[3*n],w[3*E+1]=U[3*n+1],w[3*E+2]=U[3*n+2]}return w}if(0===c.lookupMethod&&0===c.compressionMethod){if(3*c.count+b!==a.byteLength||0!==c.colorMapCount)throw new y.A("lepcc-decode-error","Bad count");return new Uint8Array(a,b).slice()}if(c.lookupMethod<=2&&1===c.compressionMethod){if(b+3!==a.byteLength||1!==c.colorMapCount)throw new y.A("lepcc-decode-error","Bad count");const U=l.getUint8(b),B=l.getUint8(b+1),w=l.getUint8(b+2),E=new Uint8Array(3*c.count);for(let n=0;n<c.count;n++)E[3*n]=U,E[3*n+1]=B,E[3*n+2]=w;return E}throw new y.A("lepcc-decode-error","Bad method "+c.lookupMethod+","+c.compressionMethod)}const P={sizeLo:0,sizeHi:4,count:8,scaleFactor:12,bitsPerPoint:14,reserved:15,byteCount:16};function Z(a){const l=new DataView(a,0);let b=0;const{identifier:O,version:D}=z(a,l,b);if(b+=L.byteCount,"Intensity "!==O)throw new y.A("lepcc-decode-error","Bad identifier");if(D>1)throw new y.A("lepcc-decode-error","Unknown version");const c=function N(a,l){return{sizeLo:a.getUint32(l+P.sizeLo,A),sizeHi:a.getUint32(l+P.sizeHi,A),count:a.getUint32(l+P.count,A),scaleFactor:a.getUint16(l+P.scaleFactor,A),bitsPerPoint:a.getUint8(l+P.bitsPerPoint),reserved:a.getUint8(l+P.reserved)}}(l,b);if(b+=P.byteCount,c.sizeHi*2**32+c.sizeLo!==a.byteLength)throw new y.A("lepcc-decode-error","Bad size");const U=new Uint16Array(c.count);if(8===c.bitsPerPoint){if(c.count+b!==a.byteLength)throw new y.A("lepcc-decode-error","Bad size");const B=new Uint8Array(a,b,c.count);for(let w=0;w<c.count;w++)U[w]=B[w]*c.scaleFactor}else if(16===c.bitsPerPoint){if(2*c.count+b!==a.byteLength)throw new y.A("lepcc-decode-error","Bad size");const B=new Uint16Array(a,b,c.count);for(let w=0;w<c.count;w++)U[w]=B[w]*c.scaleFactor}else{const B=[];if(k(a,b,B)!==a.byteLength)throw new y.A("lepcc-decode-error","Bad size");for(let w=0;w<c.count;w++)U[w]=B[w]*c.scaleFactor}return U}}}]);